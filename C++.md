### i++/++i是不是原子操作
i++ 不是，i++分为3个步骤
+ 内存到寄存器
+ 寄存器自增
+ 写回内存

这三个阶段中间都可以被中断分离开

++i 需要看编译器优化，而且在多核编程也需要加锁处理。

### 智能的指针的实现

### fopen是不是系统调用 与库函数 
下面才是**系统调用**
+ fcntl  文件控制  
+ open  打开文件   
+ creat  创建新文件  
+ close  关闭文件描述字  
+ read  读文件  
+ write  写文件  
+ readv  从文件读入数据到缓冲数组中  
+ writev  将缓冲数组里的数据写入文件  
+ pread 对文件随机读  
+ pwrite  对文件随机写 

### 默认构造函数、拷贝构造函数的作用


>当一个类派生自一个含有默认构造函数的基类时，该类也符合编译器需要合成默认构造函数的条件。编译器合成的默认构造函数将根据基类声明顺序调用上层的基类默认构造函数。同样的道理，如果设计者定义了多个构造函数，编译器将不会重新定义一个合成默认构造函数，而是把合成默认构造函数的内容插入到每一个构造函数中去。

注意是当编译器需要的时候，那什么时候编译器需要呢？


### 浅拷贝深拷贝的应用
例如string vectot<int> 深拷贝
智能指针 share_ptr<int> 浅拷贝

### new 和 malloc 区别 

> 本质区别 malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。
+ 1、new自动计算需要分配的空间，而malloc需要手工计算字节数
+ 2、new是类型安全的，而malloc不是，比如：
int* p = new float[2]; // 编译时指出错误
int* p = malloc(2*sizeof(float)); // 编译时无法指出错误
new operator 由两步构成，分别是 operator new 和construct
+ 3、operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力
+ 4、new将调用constructor，而malloc不能；delete将调用destructor，而free不能。
+ 5、malloc/free要库文件支持，new/delete则不要。 

### c++怎么实现多态
指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 
+ 编译时多态性：通过重载函数实现 
+ 运行时多态性：通过虚函数实现。 
>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。

### 虚函数实现机制 
对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的
vptr 执行一个虚函数表，然后子类对齐进行覆盖


### 构造函数可以是虚函数么，析构函数呢
，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数   
从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数
### 虚函数和普通成员函数哪个快

### 虚函数能内联么。


### 私有继承是is-a还是has-a
> 私有继承 属于has-a 的关系[在理解下](http://blog.csdn.net/lixungogogo/article/details/51134157)

### vector如何扩容？具体过程？  (手写代码)
vector当有2倍的存储空间的开始扩容。容量为原来的2倍；


### vector和list的区别？适用场景？
vector拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。
list就是数据结构中的双向链表，因此它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。
如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector
如果需要大量的插入和删除，而不关心随即存取，则应使用list

### 仿函数和函数指针的区别？
仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了;  函数对象（仿函数）——顾名思义，函数对象首先是一个对象，即某个类的实例。
仿函数比一般函数更灵巧，因为它可以永远状态，事实上对于仿函数，你可以同事拥有两个状态不同的实体，一般函数则力未能逮。
2）每个仿函数都有其类型，因此你可以将仿函数的类型当作template参数来传递，从而指定某种行为模式。此外还有一个好处：容器类型也会因为仿函数的不同而不同

还有就是效率问题，函数指针的调用，我们的电脑需要做很多工作，比如说保存当前的寄存器值，传递参数，返回值，返回到函数调用地方继续执行等。
仿函数配接器

### shared_ptr什么时候引用计数加1？
1. 在构造对象指正的时候默认为1
2. 拷贝构造函数的函数的
3. 使用赋值运算符的时候

### STL-sort 
Intro 排序
1. 控制层数 
防止递归过深
1. 如果递归过深 则采用堆排序 
+ 当元素个数少于一定值得时候则采用插入排序。

### 容器算法迭代器的关系
+ 容器：容纳各种数据类型的数据结构，是一系列的类模板。
+ 迭代器：迭代器用来迭代地访问容器中的元素。
+ 算法：用来操作容器中的元素，是一系列的函数模板。

### 迭代器都有哪几种
            input         output
              \            /
                 forward
                     |
                bidirectional
                     |
               random access
### 适配器有哪几种 /*重点看下*/
1. 分为容器的适配器  stack queue 
2. 迭代器的适配器  insert iterator stream_iterator reverse iterators mover_iterators 
3. 仿函数的的适配功能 bind1st bind2st not2 not ptr_fun compose mem_fun 


### 排序算法在复习

### 内存泄漏如何检测，如何
原因： 使用内存，而没有释放 
1. 解决方案 使用开源工具 valgrind
2. 对象计数 构造+1 析构 -1 定期打印
3. 使用函数指针

### 简单介绍堆和栈的区别
 分配方式：
 由编译器自动分配释放，存放函数的参数值，局部变量的值等。
 一般由程序员分配释放,若程序员不释放,程序结束时可能由OS回收,分配方式链表。 
大小： 系统栈空间下，向高地址扩展。
申请效率 栈速度快，无法控制
         堆速度慢可控制

### 一般情况下在windows平台下栈空间的大小
linux 默认为8M

### 介绍gdb常用命令，如果一个程序已经运行，怎样进行调试。
http://blog.csdn.net/roland_sun/article/details/42460663

### kill 进程时杀不掉的原因  kill -9 中-9是什么意思
1. 程序是僵死进程 
2. 程序处于内核态
SIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。但是SIGKILL信号不同，它可以被捕获和解释（或忽略）的过程。

SIGKILL是发送到处理的信号以使其立即终止。当发送到程序，SIGKILL使其立即终止。在对比SIGTERM和SIGINT，这个信号不能被捕获或忽略，并且在接收过程中不能执行任何清理在接收到该信


### 哈希表的冲突解决方式    
[目录]()http://blog.csdn.net/qq_27093465/article/details/52269862
1. 线性探查
2. 二次探查
3. 开链
4. 在hash

### hash 方式
线性哈希：hash(key)=a×key+b
平方哈希：hash(key)=sub(key2,a,b)，设函数 sub(num,a,b) 代表取 num 第 a 位数到第 b 位数，则
余数哈希：hash(key)=key
### 哈希表在桶固定的情况下，时间复杂度。怎么优化   
1. ？ 没知道，根据存储数据优化hash函数，开链的方式，采用红黑树 。

### 多线程中哈希表保证线程安全   
每个bucket带有一个共享锁boost::shared_mutex，从而实现线程安全的高并发

### 哈希表特别大，桶特别多的时候怎么加锁   
  cas 无锁队列 
  http://coolshell.cn/articles/8239.html  


### http的长连接和短连接是什么，各有什么优缺点，然后使用场景   
在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：
Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 

    
	
### 动态绑定怎么实现？（就是问了一下基类与派生类指针和引用的转换问题）  



### 类型转换有哪些？（四种类型转换，分别举例说明）  
+ const_cast 去const属性
+ reinterpret_cast 转一个指针类型为其他类型
+ static_cast 
    + 基本类型转换
    + 由子类转换为父类安全，由父转为儿子。不安全。
    + 空指针到其他指针
    + 如果A B 类无关报错
+ dynamitc_cast 作用于引用和指针，父亲转化为儿子会检查是否有效
~~~ C++
class Base { virtual dummy() {} };
class Derived : public Base {};
 
Base* b1 = new Derived;
Base* b2 = new Base;
 
Derived* d1 = dynamic_cast<Derived *>(b1); // succeeds
Derived* d2 = dynamic_cast<Derived *>(b2); // fails: returns 'NULL'
~~~



### 操作符重载（+操作符），具体如何去定义，？（让把操作符重载函数原型说一遍）  
返回值 operator==(输入参数 1 输入参数2){

}
	
### 内存对齐的原则？（原则叙述了一下并举例说明）  
+ 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。

+ 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。

+ 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。

4).sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。

\#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

### 模版怎么实现？ 
模式匹配 与惰性计算
### 指针和const的用法？（就是四种情况说了一下）  
int *p；
const int *p;
int * const p;
int const *p;
int const * const p;
### 虚函数、纯虚函数、虚函数与析构函数？（纯虚函数如何定义，为什么析构函数要定义成虚函数）  

纯虚函数在基类中是没有定义的，必须在子类中加以实现，
virtual <类型><函数名>(<参数表>)=0; 

我们知道，为了能够正确的调用对象的析构函数，一般要求具有层次结构的顶级类定义其析构函数为虚函数。因为在delete一个抽象类指针时候，必须要通过虚函数找到真正的析构函数。
	
### 内联函数（讲了一下内联函数的优点以及和宏定义的区别）  
内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。

宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的

 内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近

宏的缺点：
宏不能访问对象的私有成员。
宏的定义很容易产生二意性。

### using 定义别名
 c++11中的using关键字可以实现typedef的功能，而using的定义顺序有利于查找 

### const和typedef（主要讲了const的用处，有那些优点）  
		
### 链接指示：extern “C”（作用）  
	
//[兼容C](https://github.com/hokein/Wiki/wiki/extern-%22C%22)
在C++中常在头文件见到extern "C"修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。

C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符时带有函数参数类型的信息，而C则没有。

例如int add(int a, int b)函数经过C++编译器生成.o文件后，add会变成形如add_int_int之类的, 而C的话则会是形如_add, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。

这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时extern "C"就起作用了：告诉链接器去寻找_add这类的C语言符号，而不是经过C++修饰的符号。

### c语言和c++有什么区别？（大体讲了 一下，继承、多态、封装、异常处理等）  


### const关键字的作用？（const成员函数，函数传递，和define的区别） 

### static 关键字的作用 

### 静态成员函数和数据成员有什么意义？ 

### 继承机制中对象之间是如何转换的？ 
		
### 继承机制中引用和指针之间如何转换？ 
		
### 虚函数，虚函数表里面内存如何分配？（这个考前看过了，答的还不错）  
		
### 如何实现只能动态分配类对象，不能定义类对象？（这个牛客上的题目，我把如何只能动态分配和只能静态分配都讲了一下）  
			
### stl有哪些容器，对比vector和set 
			
### 红黑树的定义和解释
		
### 模版特化的概念，为什么特化？ 
		
### explicit是干什么用的？ 
			
### strcpy返回类型是干嘛用的？ 
		
### 内存溢出有那些因素？ 
		
### new与malloc的区别，delet和free的区别？ 
			
### 异常机制是怎么回事？ 
		
### 迭代器删除元素的会发生什么？ 
		
### 必须在构造函数初始化式里进行初始化的数据成员有哪些？ 
		
### 类的封装：private，protected，public 
		
### auto_ptr类： 



### 类的方法
成员方法又称为实例方法
静态方法又称为类方法

class Base 
{
  public:
  virtual   ~Base(){std::out<<”Base Destructor”<<std::endl;}
}
class Derived: public Base 
{
  public :
   ~Derived(){std::out<<”Derived    Destructor” <<std::endl;}
}


### 如何定义一个只能在堆上（栈上）生成对象的类?
https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618  