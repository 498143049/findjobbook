### 程序编译链接过程
总结: http://jzhihui.iteye.com/blog/1447570
1. 编译阶段
+ 程序预处理 将宏展开，以及条件编译的各种预处理指令
+ 程序编译阶段 将C语言转化为汇编代码 
+ 将程序汇编代码转为机器码 一共可以转化为 可定位文件 共享文件  可执行文件
+ 静态库  动态库
+ 链接器 
### ELF 文件 目标文件 

### 程序运行时的内存分布 
+ 有内核工具有需要的内存，如果在其中写入数据，就会造成段错误
+ 代码区域 
+ 程序的堆/站  heap 由低地址到高地址  stack 由低地址到高地址
+ 动态库文件区域 
+ BSS   该段用来存放没有被初始化或初始化为0的全局变量
+ data  初始化过的全局变量数据段，该段用来保存初始化了的非0的全局变量
+ rodata段放常量数据


### STL 优缺点 

### 程序调试内容 coredump + GDB
通过配置使得coredump 可用，然后使用GDB工具去定位，然后发现段错误的具体位置
http://blog.csdn.net/ithomer/article/details/5945152

线程调试  LWP(light weight process) 
https://www.google.com/search?q=LWP%E5%92%8Cstrace%E5%91%BD%E4%BB%A4&oq=LWP%E5%92%8Cstrace%E5%91%BD%E4%BB%A4&aqs=chrome..69i57j69i61.608j0j4&sourceid=chrome&ie=UTF-8

### linux 常见指令
ulimit -s 给定栈空间的大小

### linux-内存分配原则
Linux内存分配——伙伴系统
目的：最大限度的降低内存的碎片化。
1将内存块分为了11个连续的页框块（1,2,4,8....512,1024），其中每一个页框块中用链表将内存块对应内存大小的块进行链接。
若需要一块256大小的内存块，则从对应的256链表中查找空余的内存块，若有则分配。否则查找512等等。
3.若在256中未找到空余内存块，在512中查找到空余的内存块。则将512分成两部分，一部分进行分配，另一部分则插入256链表中。

内存的释放过程与分配过程相反。在分配过程中由大块分解而成的小块中没有被分配的块将一直等着被分配的块被释放，从而和其合并。最终相当于没有划分小块。
首次适应法 最佳适应法 最坏适应法 循环首次适应法 

总结：伙伴系统在分配和释放的过程中执行互逆的过程，其将会极大力度的抵消碎片的产生。
// http://blog.csdn.net/ojshilu/article/details/17001165

### 内存管理系统 (段/页)
内存的分配方式 
伙伴系统
内存的优化


通过交换系统
覆盖技术通过在小内存的可以运行大程序。

内存存储管理 
http://blog.csdn.net/hguisu/article/details/5713164 
页 没有 外碎片 
段 没有 内碎片
分页仅仅是由于系统管理的需要
分段的目的是为了更好地满足用户的需要

比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。


