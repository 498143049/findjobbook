https://www.nowcoder.com/questionTerminal/6bb6fdc034c34022a18bbbfa6a173350

与操作系统有关的方式 
1. CPU 
+ 调度  1. 先到先服务FCFS，不可抢站， 短作业优先SJF， 优先权调度  轮转法调度 多级队列调度  实时调度  https://github.com/chyyuu/simple_os_book/blob/master/zh/chapter-4/process_schedule_principal.md  这几种调度算法的优缺点 
  进程的三种形态 **就绪、运行、 阻塞**
+ 线程同步方式   
### 管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
### 有名管道 (named pipe): 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
# 信号量(semophore): 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
# 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
# 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
#共享内存( shared memory)：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
### 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
管道的主要局限性正体现在它的特点上:
+ 只支持单向数据流；
+ 只能用于具有亲缘关系的进程之间；
+ 没有名字；
+ 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
+ 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；
### 无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错。
### 消息缓冲可以不再局限于父子进程．而允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题．使用方便，但是信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合。
3.共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。
socket  可以通过分布式 

+ 进程的同步方式
1. 互斥 信号量  条件变量
互斥是保护资源 
和信号量则是调配资源
条件变量在互斥比较复杂的时候的时候有用
2. 其他的有文件锁 读写锁  以及 自旋锁 

### 死锁条件
1. 互斥条件
2. 不可剥夺
3. 请求保持
4. 环路等待 

### 防止死锁的方式 
1. 预防 
2. 检测 定时检测 效率低时检测
3. 分配的资源  撤销挂起一些进程 



### 内存 
+ 内存的分配方式 伙伴系统，基于链表的分配 
+ 内存的存储管理  


目的：最大限度的降低内存的碎片化。
1将内存块分为了11个连续的页框块（1,2,4,8....512,1024），其中每一个页框块中用链表将内存块对应内存大小的块进行链接。
若需要一块256大小的内存块，则从对应的256链表中查找空余的内存块，若有则分配。否则查找512等等。
3.若在256中未找到空余内存块，在512中查找到空余的内存块。则将512分成两部分，一部分进行分配，另一部分则插入256链表中。

内存的释放过程与分配过程相反。在分配过程中由大块分解而成的小块中没有被分配的块将一直等着被分配的块被释放，从而和其合并。最终相当于没有划分小块。
首次适应法 最佳适应法 最坏适应法 循环首次适应法 

总结：伙伴系统在分配和释放的过程中执行互逆的过程，其将会极大力度的抵消碎片的产生。
// http://blog.csdn.net/ojshilu/article/details/17001165

### 页面抖动
减少 页面都得用 
为了减少页抖动，你应该减少同时运行的程序的数目。
对于大的程序，你应该改变它的工作方式，以尽量使操作系统能准确地判断出哪些页不再需要。
改变内存分配方式使用效率更高的malloc()函数。
增加系统的RAM，以减少页出动作

### IO 
+ IO控制的方式   http://blog.csdn.net/ajian005/article/details/18182953
4种 
+ IO 与 DMA CPU 的区别
+ IO通道和一般处理器的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序释放在主机内存中的，也就是说通道与CPU共享内存
+ IO通道与DMA的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。 
### 缓冲技术
+ 无缓存IO操作数据流向路径：数据——内核缓存区——磁盘
+ 标准IO操作数据流向路径：数据——流缓存区——内核缓存区——磁盘

### 多路复用机制 
+ select，poll，epoll 
http://www.jianshu.com/p/dfd940e7fca2

###  同步 异步 
同步异步，阻塞非阻塞




### 文件磁盘管理者一块
http://www.bijishequ.com/detail/375381?p=
+ 磁盘读取原理 文件目录检索 

+ 关于程序的编译链接过程

+ 关于程序的进程分布 

+ 关于程序该如何调试 


静止就绪：这个也叫做挂起就绪，是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。

活动就绪：进程在主存并且可被调度的状态。

静止睡眠（阻塞）：是指进程对换到辅存时的阻塞状态，一旦等待的事件产生便进入静止就绪状态。
活动睡眠（阻塞）：是指进程已在主存，一旦等待的事件产生便进入活跃就绪状态。

正在执行的进程由于其时间片用完被暂停执行，此时进程应从执行状态变为活动就绪状态；
处于静止睡眠状态的进程，在进程等待的事件出现后，应变为静止就绪状态；
若进程正处于执行状态时，因终端的请求而暂停下来以便研究其运行情况，这时进程应转变为静止就绪状态；若进程已处于睡眠状态，则此时应转变为静止睡眠状态。

### 内存池

### 线程池
https://www.ibm.com/developerworks/cn/java/l-threadPool/ 
### 连接池
http://blog.csdn.net/wwh578867817/article/details/46451193

### auto ptr的问题
https://www.zhihu.com/question/37351146/answer/71576902

为什么要设计进程
后面告诉我可以从进程演化历史、批处理、多道程序设计、进程间通信考虑

### 内存管理位图 空闲链表 
http://blog.csdn.net/topasstem8/article/details/42558233

作者：xndxcsd
链接：https://www.nowcoder.com/discuss/29617?type%3D2%26order%3D3%26pos%3D8%26page%3D1
来源：牛客网

多线程应用题，五个运动员（相当于五个线程）一个裁判（相当于主线程），满足一下3个条件，如何实现：
1.要同时起跑
2.要所有运动员都到达终点以后才能进行下一个环节
3.如果有一个运动员摔跤了（异常处理），就终止这次比赛，让所有运动员都到终点进行下一个环节

epoll的水平触发和边沿触发（这一块问的很深就，涉及到底层的实现和数据处理一半的情况等等）

内存中 堆和栈 的区别，栈底层如何实现？是一上来就分配4MB吗？缺页中断时操作系统怎么做？

epoll和select底层使用的数据结构
http://blog.csdn.net/lixungogogo/article/details/52226501 
http://www.cnblogs.com/lojunren/p/3856290.html
缺页替换算法
http://blog.csdn.net/u011080472/article/details/51206332

http://blog.csdn.net/zangyuanan320/article/details/52091500

inux查看监听端口，某个pid占用cpu，top

文件描述符知道吧？同一个进程打开同一个文件两次，会发生什么？具体说说文件的底层数据结构

我说用C 11的原子变量，他不满意，说这样其实也是锁，只不过是底层实现的，比mutex更效率一些。我说我想不到其他方法。然后他提示了一下，说不一定非要对变量本身进行操作。这个时候我一下子明白了，原来题意是两个线程只对变量进行 --操作，没有其他，那完全可以在启动线程前，将变量的值赋值给两个变量，然后通过ref()的方式传给线程，最后将两个值相加即可，不需要加锁

无锁化 CAS

 8.select怎么实现的 